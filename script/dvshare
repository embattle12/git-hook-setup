#!/usr/bin/env bash
# dvshare: lightweight local "share/apply" for uncommitted files
# Stores packages under .git/dv-share/<SESSION>
# Commands:
#   dvshare share --label <name> --ttl <3m|2h|1d> -- <file...>
#   dvshare apply --from <pkgdir>
#   dvshare list
#   dvshare prune
set -euo pipefail

fail(){ echo "ERROR: $*" >&2; exit 1; }
info(){ echo "$*" >&2; }

# --- repo root ---
git rev-parse --show-toplevel >/dev/null 2>&1 || fail "Run inside a git repo."
ROOT="$(git rev-parse --show-toplevel)"
STORE="$ROOT/.git/dv-share"
mkdir -p "$STORE"

# --- ttl parsing ---
add_ttl(){
  # Arg1: TTL string like 3m, 2h, 1d ; prints ISO timestamp
  local ttl="${1:-}"
  [[ -n "$ttl" ]] || fail "missing ttl"
  local secs
  case "$ttl" in
    *m) secs=$(( ${ttl%m} * 60 ));;
    *h) secs=$(( ${ttl%h} * 3600 ));;
    *d) secs=$(( ${ttl%d} * 86400 ));;
    *)  secs="$ttl";; # raw seconds
  esac
  # GNU date (Linux) vs BSD (macOS); fall back if needed
  if date -d "@0" >/dev/null 2>&1; then
    date -u -d "@$(( $(date +%s) + secs ))" +"%Y-%m-%dT%H:%M:%SZ"
  else
    date -u -r "$(( $(date +%s) + secs ))" +"%Y-%m-%dT%H:%M:%SZ"
  fi
}

json_escape() {
  # minimal escaper for double-quoted JSON strings
  printf '%s' "$1" | python - "$@" 2>/dev/null <<'PY' || printf '%s' "$1"
import json,sys
print(json.dumps(sys.stdin.read()))
PY
}

abs_path() {
  # POSIX-ish absolute path resolver
  python - "$@" 2>/dev/null <<'PY' || echo "$1"
import os,sys
p=sys.argv[1]
print(os.path.abspath(p))
PY
}

rel_to_root() {
  python - "$@" 2>/dev/null <<'PY' || echo "$1"
import os,sys
root, p = sys.argv[1], sys.argv[2]
print(os.path.relpath(os.path.abspath(p), root).replace("\\","/"))
PY
}

usage() {
cat <<EOF
Usage:
  dvshare share --label <name> --ttl <3m|2h|1d> -- <file...>
  dvshare apply --from <pkgdir>
  dvshare list
  dvshare prune
EOF
}

cmd="${1:-}"; shift || true
case "$cmd" in
  share)
    label=""
    ttl=""
    # parse flags until '--'
    while [[ $# -gt 0 ]]; do
      case "${1:-}" in
        --label) label="${2:-}"; shift 2;;
        --ttl)   ttl="${2:-}"; shift 2;;
        --) shift; break;;
        -h|--help) usage; exit 0;;
        *) fail "unknown flag: $1";;
      esac
    done
    [[ -n "$label" ]] || fail "share: --label required"
    [[ -n "$ttl" ]]   || fail "share: --ttl required"
    [[ $# -ge 1 ]]    || fail "share: provide at least one file after --"

    SESSION="$(date +%Y%m%d%H%M%S)-$RANDOM"
    PKG="$STORE/$SESSION"
    PAY="$PKG/payload"
    mkdir -p "$PAY"

    created="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
    expires="$(add_ttl "$ttl")"

    files_json="[]"
    tmp_files=()
    # copy each file keeping repo-relative path
    for f in "$@"; do
      # allow absolute or relative input
      apath="$(abs_path "$f")"
      # ensure file exists (can be untracked)
      [[ -f "$apath" ]] || fail "file not found: $f"
      rel="$(rel_to_root "$ROOT" "$apath")"
      tmp_files+=("$rel")
      mkdir -p "$PAY/$(dirname "$rel")"
      cp -p "$apath" "$PAY/$rel"
    done

    # build files array JSON
    printf '[' > "$PKG/.files.tmp"
    first=1
    for rel in "${tmp_files[@]}"; do
      j=$(json_escape "$rel")
      if [[ $first -eq 1 ]]; then
        printf '%s' "$j" >> "$PKG/.files.tmp"; first=0
      else
        printf ',%s' "$j" >> "$PKG/.files.tmp"
      fi
    done
    printf ']\n' >> "$PKG/.files.tmp"
    files_json="$(cat "$PKG/.files.tmp")"; rm -f "$PKG/.files.tmp"

    # write manifest
    MAN="$PKG/manifest.json"
    {
      echo '{'
      echo "  \"session\": \"${SESSION}\","
      echo "  \"label\": $(json_escape "$label"),"
      echo "  \"created_at\": \"${created}\","
      echo "  \"expires_at\": \"${expires}\","
      echo "  \"sender_root\": $(json_escape "$ROOT"),"
      echo "  \"files\": ${files_json}"
      echo '}'
    } > "$MAN"

    echo "SESSION=$SESSION"
    echo "PKGDIR=$PKG"
    echo "FILES=${#tmp_files[@]}"
    ;;

  apply)
    from=""
    while [[ $# -gt 0 ]]; do
      case "${1:-}" in
        --from) from="${2:-}"; shift 2;;
        -h|--help) usage; exit 0;;
        *) fail "unknown flag: $1";;
      esac
    done
    [[ -n "$from" ]] || fail "apply: --from <pkgdir> required"
    [[ -d "$from" ]] || fail "apply: directory not found: $from"

    MAN="$from/manifest.json"
    PAY="$from/payload"
    [[ -f "$MAN" ]] || fail "manifest not found in $from"
    [[ -d "$PAY" ]] || fail "payload/ not found in $from"

    # Read files list from manifest using python for safety
    mapfile -t rels < <(python - "$MAN" <<'PY'
import json,sys
with open(sys.argv[1], 'r', encoding='utf-8') as f:
    m=json.load(f)
for p in m.get('files',[]):
    print(p)
PY
)
    [[ ${#rels[@]} -gt 0 ]] || fail "no files listed in manifest"

    for rel in "${rels[@]}"; do
      src="$PAY/$rel"
      dst="$ROOT/$rel"
      mkdir -p "$(dirname "$dst")"
      cp -p "$src" "$dst"
      echo "APPLIED: $rel"
    done
    ;;

  list)
    shopt -s nullglob
    for d in "$STORE"/*; do
      [[ -d "$d" ]] || continue
      man="$d/manifest.json"
      if [[ -f "$man" ]]; then
        session="$(basename "$d")"
        label="$(awk -F\" '/"label":/ {print $4}' "$man" || true)"
        expires="$(awk -F\" '/"expires_at":/ {print $4}' "$man" || true)"
        echo "$session  $label  (expires: $expires)"
      fi
    done
    ;;

  prune)
    shopt -s nullglob
    now_epoch="$(date +%s)"
    for d in "$STORE"/*; do
      man="$d/manifest.json"
      [[ -f "$man" ]] || { rm -rf "$d"; continue; }
      exp="$(awk -F\" '/"expires_at":/ {print $4}' "$man" || true)"
      [[ -n "$exp" ]] || { rm -rf "$d"; continue; }
      # Convert ISO to epoch
      if date -d "$exp" +%s >/dev/null 2>&1; then
        exp_epoch="$(date -d "$exp" +%s)"
      else
        exp_epoch="$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$exp" +%s 2>/dev/null || echo 0)"
      fi
      if [[ "$exp_epoch" -gt 0 && "$now_epoch" -ge "$exp_epoch" ]]; then
        echo "PRUNE: $(basename "$d")"
        rm -rf "$d"
      fi
    done
    ;;

  -h|--help|"")
    usage; exit 0;;
  *)
    usage; fail "unknown command: $cmd";;
esac
